LogWatchのカスタマイズ,v 1.8 2006/02/28 19:34:24 bjorn
================================================================================

1. 目次
-------

contents

1. 目次
2. 導入
3. ディレクトリ構造
  1. 設定の構造
  2. 実行ファイルの構造
4. 設定のカスタマイズ
5. スクリプトのカスタマイズ
6. 新しいサービス/フィルタを作る
  1. ログファイル・グループ
  2. サービス・フィルタの設定
  3. サービス・フィルタの実行ファイル
7. より多くの情報を得るには

この文書は配布物の中のLogwatchファイルの構造および、あなたのシステムの設定の変更方法、新しいサービス・フィルタの作成方法を説明します。


2. 導入
-------

Logwatchはシステムログ解析および報告システムです。Logwatchの使い方の情報はmanページから見ることもできます。

```
   man logwatch
```

manページの ``"MORE INFORMATION"`` というタイトルのセクションに配布物の中の追加の文書ファイルのリストがあります。

manページで説明されているコマンドラインのスイッチに関する概要は ``'--help'`` オプションによっても見ることができます。

```
logwatch --help
```

このドキュメントの以降の部分では、コマンドラインのスイッチでできる以上にLogwatchをカスタマイズまたは強化するための説明をしていきます。


3. ディレクトリ構造
-------------------

このセクションではLogwatch配布物とともに配布されるサブディレクトリとファイルの、デフォルトで使用される名前と場所を説明します。

``/usr/share/logwatch`` ディレクトリには設定と実行ファイル(perl)の両方があります。このディレクトリの中身は下記のサブディレクトリです。

```
    default.conf:   Logwatch配布物のデフォルトの設定ファイルがあります。

    dift.conf:      あなたのOSディストリビューション固有の設定ファイルがあります。

    lib:            ライブラリ・ファイルがあります。

    scripts:        perl実行ファイルがあります。
```

``/etc/logwatch`` ディレクトリには下記のサブディレクトリがあります：

```
    conf:       システム固有の設定ファイルがあります。

    scripts:    システム固有の実行スクリプトがあります。
```

### i. 設定の構造

``/usr/share/logwatch/default.conf`` および ``/usr/sahre/logwatch/dist.conf`` ,
``/etc/logwatch/conf`` の3つのディレクトリの中は、全て同じ構造を持っています。

```
    services:   このサブディレクトリにはサービス毎に特有の設定ファイルがあります。
                Logwatchはこのディレクトリの中を検査することで、サービスが利用可能か
                どうかを決めます。それぞれのサービスの設定ファイルはそのサービスの
                名前に接尾語".conf"を付けたものです。

    logfiles:   このサブディレクトリにはログファイル・グループ設定ファイルがあります。
                それぞれのログファイル・グループ設定ファイルには同じフォーマットの
                1無いし複数のログファイルの情報があります。いくつものサービスが同じ
                ログファイル・グループ設定ファイルを使うかもしれません。これらの
                設定ファイルのそれぞれはグループの名前に接尾語".conf"を付けた名前に
                なります。グループ名の多くはシステムログファイルの名前から採られて
                います（メッセージ、メールログ、セキュリティのような）が、常にそうで
                あるとは限りません。

    logwatch.conf:  このファイルにはLogwatchの全般的な実行、そしてそのサービス全体への
                デフォルトがあります。パラメータの多くはLogwatchの実行時に、manページで
                説明されているようなコマンドラインのスイッチで上書きすることができます。

    ignore.conf:    このファイルで指定した正規表現とlogwatchの出力がマッチすると、
                たとえそのサービスが実行されていても、マッチした行を省略されます。
```

``/etc/logwatch/conf`` ディレクトリには セクション4"設定のカスタマイズ"で説明する、
``'override.conf'`` ファイルがあるかもしれません。


### ii. 実行ファイルの構造

``/usr/share/logwatch/scripts`` および ``/etc/logwatch/scripts`` の2つのディレクトリの
中は同じ構造です。

```
    services:   このサブディレクトリにはそれぞれのサービスの実行ファイルがあります。
            サービスの設定ファイル（上記参照）で指定されていなければ実行ファイルは
            perl言語で書かれています。

    shared:  このサブディレクトリには1つ以上のサービスファイルで共有される
            かもしれない実行ファイルがあります。

    logfiles:   このサブディレクトリにはログファイル・グループ名のサブディレクトリが
            あるかもしれません。これらのサブディレクトリのそれぞれの下にある
            実行ファイルはサービスとして実行される時に自動的にログファイル・
            グループ名を使用します。
```

4. 設定のカスタマイズ
---------------------

Logwatchは多くのバリエーションのLinuxおよびUNIXシステムで使用するかもしれませんし、
また使用されています。Logwatchを含むディストリビューションのうち、あるものは
ディストリビューションの設定に合わせるためにデフォルトの設定を変更します。
そのため、多くの人々はlogwatchを変更する必要はありません。

しかしながら、logwatchはバージョン7.0より、ローカルなシステムのユーザーに
変更を行えるようにするメカニズムを実装しました。これらの変更は、システムログに
書き込むサービスの設定がデフォルトから変更されていたり、logwatchのユーザーが
何をレポートするか、どのようにレポートするかを変更したい時に必要になります。

``/etc/logwatch/conf`` ディレクトリの変数を変更することで、logwatchの出力を
カスタマイズすることができます。

デフォルトの値は ``/usr/share/logwatch/default.conf`` ディレクトリで
指定されています。あなたのディストリビューションでは 
``/usr/share/logwatch/dist.conf`` ディレクトリに追加のデフォルトのセットが
あるかもしれません。使用可能な全ての変数はこれらのディレクトリの下にある
ファイルで定義されています。logwatchが何をどう表示するか変更するために
デフォルトの値を変更することができます。

全てのサービスで利用可能で、デフォルトでは指定されていない変数は'Detail'変数
（'$'記号より先にはあらわれません）です。Detailの値を指定するとglobalを
Detailのレベルで、そのサービスについて上書きします

変数のカスタマイズには2つの方法があります：

同じ名前のファイルが探索されます。最初に ``/etc/logwatch/conf`` ディレクトリ、
そして ``/usr/share/logwatch/default.conf`` ディレクトリです。これらのファイルで
変数のデフォルトは上書きされます。
例えば、もし ``/etc/logwatch/conf/services/sendmail.conf`` がエントリを1つ
持っていたとします。

```
        $sendmail_unknownusersthreshold = 5
```

未知のユーザーのしきい値に、デフォルトの値に代わって5が設定されました。
他の全てのパラメータは変更されていません。

設定ファイルには異なる4種類の定義があり、それぞれの行の先頭の先頭の文字で決まります：

```
    '#': 行の続きはコメントとして、無視されます。
    '$': 行の続きの1つめのフィールドは変数です。
    '*': 実行スクリプトの名前を示します。
```

空白行以外の、他の定義は ``LogFile`` 、 ``Archive`` 、他のような変数名に予約されています。

全般において、変数の設定はそれ以前に設定された値を上書きします。
しかしながら、下記の変数は累積します。

- logwatch.conf内: LogFile, Service
- services/service_name.conf内: LogFile
- logfiles/service_name.conf内: LogFile, Archive

その変数の以前の設定を全て取り除くには、変数に空の文字列を設定します。
累積する変数の重複する値は削除されます。

もし実行可能なスクリプトが ``/etc/logwatch/conf`` ファイルに定義されていたら、 ``/usr/share/logwatch/default.conf`` または ``/usr/share/logwatch/dist.conf`` の全ての実行可能なファイルの定義が無視されます。

そのため変数と実行スクリプトが定義されたら、 ``/etc/logwatch/conf/`` の中のファイルを2つの方法で作ることができます:

- 変更する変数（そして、もし必要なら新しい実行スクリプトの定義）だけの新しいファイルを上記の説明のように作る。または、

- 既にある設定ファイルを ``/usr/share/logwatch/default.conf`` から ``/etc/logwatch/conf`` 内の同様の位置にコピーし、必要なだけの行を変更する。なぜなら、累積する変数から重複は取り除かれ、そして新しい実行スクリプトのグループは古いものを上書きするので、出力は正しくなるでしょう。

2. ``/etc/logwatch/conf/override.conf`` ファイルが次に探索されます。それぞれの行の先頭のフィールドは以下のようになるでしょう:

```
      #
            この文字はその行の残りがコメントであることを示し、無視されます。

      logwatch:
           この文字列は行の残りの部分がグローバルな設定オプションであることを
           示します。/usr/share/logwatch/default.conf/logwatch.confファイルと
           同じ書式を使います。

      services/service_name:
           （service_nameにはサービスの名前が入ります。）この文字列はその行の
           残りが指定されたサービスの設定オプションであることを示します。
           /usr/share/logwatch/default.conf/servicesファイルと同じ書式を
           使います。

      logfiles/service_name:
           （service_nameにはサービスの名前が入ります。）この文字列はその行の
           残りが指定されたサービスの設定オプションであることを示します。
           /usr/share/logwatch/default.conf/logfilesファイルと同じ書式を
           使います。
```

例えば、もし ``/etc/logwatch/conf/override.conf`` に1つのエントリがあったとします。

```
        logwatch: Detail = High
```

これにより、全てのサービスの ``Detail`` レベルのデフォルトが ``High`` に設定されます。

そして、 ``override.conf`` ファイルに、以下の定義があったとします:

```
        logfiles/messages: LogFile = syslog
```

指定のサービスの（デフォルトのメッセージファイルに加えて）シスログファイルが分析されます。
しかし以下の2つの設定を合わせると:

```
    logfiles/messages: LogFile = 
    logfiles/messages: LogFile = syslog
```

それらのサービスのメッセージファイルは無視され、シスログファイルだけが使われます。


5. スクリプトのカスタマイズ
---------------------------

セクション4で説明された、設定のカスタマイズと同様の方法でデフォルトの
実行ファイルも上書きすることができます。

``/etc/logwatch/scripts`` ディレクトリ下の（ ``/usr/share/logwatch/scripts`` と同じような）関係のあるパスに同じ名前の実行ファイルを配置すれば完了です。
もしそのようなファイルが ``/etc/logwatch/scripts`` にあれば、 ``/usr/share/logwatch/scripts`` 下のファイルは無視されます。

6. 新しいサービス・フィルタを作る
---------------------------------

新しいサービスは、上記で説明したような新しい設定と実行ファイルを ``/etc/logwath`` ディレクトリに配置することで作ることができます。このセクションでは追加の詳細と新しいサービス・フィルタの例を提供しますが、 ``/usr/share/logwatch`` ディレクトリのの下にある、既存の設定とスクリプトをベースに新しいファイルを作る方が簡単でしょう。

### i. ログファイル・グループ

ログファイル・グループ設定ファイルで必須なのはたった1行だけです。このコマンドは ``'LogFile'`` と呼ばれます。

```
    # これはデフォルトのログファイル・ディレクトリ(おそらくは/var/log)にある'messages'という名のログファイルになります。
    LogFile = messages
    # このように絶対パスでこのコマンドを使うことも可能です。
    LogFile = /var/log/messages
```

``LogFile`` エントリは望むだけ多く設けることができます。指定された全てのファイルはこのログファイル・グループを使用する全てのフィルタに対して1つのインプット・ストリームにマージされるでしょう。ファイル名を指定するのに標準のワイルドカードを使うこともできます。

オプションとして、 ``'Archive'`` というもう一つのコマンドがあります。もし ``'--archives'`` オプションが使われていると、ファイルをデータストリームに含まれるものとして指定できます。もしこれらのファイルが存在していなくても構いません。例えば:


```
    # これら2つの'Archive'エントリはRed Hat Linuxシステムの多くのユーザーが
    # 彼らの'messages'ログファイルにアクセスすることを許可します。
    Archive = messages.?
    # もし彼らが/etc/logrotate.confで圧縮の設定をしているならこのようになります:
    Archive = messages.?.gz
    # 多くのシステムでログファイル・グループを稼働させるのであれば、
    #これら両方を含めるのが良いでしょう。
```

現在、ログファイル・グループにリクエストされた日付の範囲を適用するのが一般的なセオリーでしょう。もしログファイルが標準的なsyslog型式であれば、妥当なログエントリだけを抽出するために、共有スクリプト ``'ApplyStdDate'`` を使うことができます。( ``/usr/share/logwatch/scripts/shared`` にある)共有スクリプトを呼び出す方法はこのようになります:

```
    *ApplyStdDate = 
```

等号に続く何かは引数としてプログラムに渡されます（引数が不要なら等号で終了します）。現在のログファイル・グループ設定ファイルを例にするのが良いでしょう。

最後に、もし ``/usr/share/logwatch/scripts/logfiles/<ログファイル・グループ名>/`` ディレクトリが存在するなら、そのディレクトリにある任意のスクリプトが実行されます。これらのスクリプトは指定された全てのログファイルを標準入力を通じて読み込み、変更されたログファイルを標準出力として出力します。

### ii. サービス・フィルタ・設定ファイル

一度、1ないしより多くのログファイル・グループを定義したら(または1ないしより多くの既存のログファイル・グループについて)、サービス・フィルタを定義する必要があります。

このファイルは ``/etc/logwatch/conf/services/`` にあって、かつ ``service_name.conf`` という名前である必要があり、 ``service_name`` はサービスの名前となります。新しいものを作るのであれば既存の他のサービス用の設定をコピーするのが良いでしょう。

必須なのは1行だけです。これは ``'LogFile'`` コマンドです。LogFileコマンドにはこのフィルタで処理する、1つないしより多くの(上記で説明した) *ログファイル・グループ* を指定します。覚えていて欲しいのは、任意のフィルタが任意の数のログファイル・グループを処理することができ、任意のログファイル・グループは任意の数のログファイル（およびアーカイブ）からのデータを含むことができるということです。

``/var/log/messages`` のメッセージを必要とするサービス・フィルタならこのような行を追加します:

```
    LogFile = messages
```

.. note::
   このようになるのは、 ``'messages'`` がログファイルの名前 *だからではなく* 、ログファイル・グループの名前が ``'messages'`` として定義されているからです。

コマンドはこのような書式になります:

```
    *SharedScriptName = Arguments
```

``/usr/share/logwatch/scripts/shared/`` ディレクトリで見つかった、 ``'SharedScriptName'`` という名前のスクリプトが ``'Arguments'`` という引数で実行されます。このフィルタはサービス・フィルタへの入力を変更します。

この書式のコマンドを書くこともできます:

```
    $EnvironmentVariable = Value
```

このコマンドは ``'EnvironmentVariable'`` 環境変数に ``'Value'`` という値を設定します。この環境変数をフィルタ・プログラムから参照することができます。

スクリプトにタイトルを指定することができます(Logwatch4.0以降)。もし指定すれば、指定したサービスについて、LogWatchにより開始と終了時にデリミタが追加されます（スクリプトの出力がそれらのデリミタの間に入ります）。これは、もし何らかの出力が作り出されたとき *だけ* になります。もし出力が無ければ、ヘッダーは作成されません。タイトルはこのように定義します:

```
    Title = "My Service Title"
```

### iii. Service Filter Executable

一度上記の全てを行ったら、実際にフィルタを書く準備ができたことになります。これは下記のことができるなら、どの言語で書くこともできます。

1) 標準入力からログファイル・エントリを読む
2) 環境変数にアクセスする
3) レポートを標準出力に書き出す

フィルタを書くことに挑戦する前に、フィルタとその内容をテストする下記のスクリプトを作りましょう。フィルタは ``/etc/logwatch/scripts/services/`` に配置し、 ``service_name`` という名前を付けます（設定ファイルに ``service_name.conf`` という名前を付けたからです）。


```
  ###################### Cut Here #########################
  #!/bin/bash
  # これは処理しレポートする行を表示するナイスなスクリプトです。
  # まず標準の環境変数を表示し、次に標準入力をそのまま標準出力に
  # ダンプします。
  #
  # これらは標準の環境変数です。サービスの設定ファイルで
  # より多く定義することができます(上記参照)。
  echo "Date Range: $LOGWATCH_DATE_RANGE"
  echo "Detail Level: $LOGWATCH_DETAIL_LEVEL"
  echo "Temp Dir: $LOGWATCH_TEMP_DIR"
  echo "Debug Level: $LOGWATCH_DEBUG"
  #
  # ここで標準入力を標準出力にダンプします。
  cat
  ###################### Cut Here #########################
```

もし一時的に'pam'のようなスクリプトを上記に置き換えれば、 ``/var/log/messages`` がこのフィルタに到達する前に切り出されてくることに気づくでしょう。

環境変数 ``LOGWATCH_DETAIL_LEVEL`` は任意の整数の値をとることができます。実際上、通常は0(低)、5(中)そして10(高)とします。

スクリプトは妥当な出力だけを行うべきです。もし意味のあるログ・エントリがなければ、何も出力するべきではありません。同様に、もし"ログイン成功"と"ログイン失敗"のような、2つのことをレポートするなら、妥当なときだけ見出しを付けましょう。例えば:

```
    Bad Logins:
       amber (2 time(s))
       kirk (3 time(s))

    Good Logins:
       amber (5 time(s))
       kirk (10 time(s))
```

しかし、ログイン失敗がなければ、出力すべきなのはこれだけです:

```
    Good Logins:
       amber (5 time(s))
       kirk (10 time(s))
```

ログイン失敗が無ければ、 ``"Bad Logins:"`` ヘッダーがないことに注意してください。また、何を出力するかの判定には ``detail`` 環境変数を使うべきです。ログイン失敗は常に表示する必要があるでしょうが、ログイン成功は ``detail`` のレベルが高い時だけにしましょう。 ``detail`` のセッティングをどう使用すべきかのガイドを示します。


```
     0 (低): エラーかつセキュリティに関する問題のみ表示
     5 (中): 典型的な管理者が興味を持ちそうなことを表示
    10 (高): 偏執症的な管理者が見たいと思うかもしれないことを表示
```

場合によっては、10より高いセキュリティ設定を使うこともできます。これは合衆国政府くらいしか興味を持ちそうにない些細な情報のために予約されるべきものでしょう。

7. より多くの情報を得るには
---------------------------

この文書の導入で情報の追加ソースをリストしてます。
加えて、ウェブサイト http://www.logwatch.org には以下があります。

- 現在の(およびアーカイブされた)logwatchの配布物
- メーリングリストへのアクセス。コメント、提案、バグレポート、その他歓迎です
- 最新のコードのためのcvsのリポジトリへのアクセス

もし他の人々にも有益と思われる新しいサービスの作成や改善を行ったら、それを ``logwatch.org`` にあるlogwatch開発メーリングリストに送ってください。

もしパッチを送ってくださるなら、cvsのファイルの最新版を確認し、( ``'cvs diff -u'`` または ``'diff -u'`` を使って)統一されたフォーマットでパッチ・ファイルを添付してください。

改善の提案は、もしその変更がパッチ・ファイルとして実装されているなら、それを送っていただいたほうが採用されやすいです。
